name: release-pullrequest-OpenShift-installer-chart

on:
  pull_request:
    paths:
      - '.github/workflows/release-pullrequest-OpenShift-installer-chart.yaml'
    branches:
      - main
  workflow_dispatch:

env:
  MODULE: installer
  GHCR_REPO: ghcr.io/${{ github.repository }}
  INSTALL_CRDS: "true"
  HAS_DEPLOYMENT: "true"

jobs:
  install-OpenShift:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        k8s_version: [ "4.16.30" ]

    steps:
      - name: Authenticate with GitHub App
        id: authenticate
        uses: tibdex/github-app-token@v1
        with:
          app_id: ${{ secrets.APP_ID }}
          private_key: ${{ secrets.PRIVATE_KEY }}

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version
        run: |
          set -euo pipefail
          git fetch --tags --force

          echo "=== TAGS IN REPO (sorted) ==="
          git tag -l --sort=-version:refname | cat

          echo
          echo "=== Searching latest tags for module '${{ env.MODULE }}' ==="
          APP_VERSION="$(
            git tag -l '${{ env.MODULE }}/*' --sort=-version:refname \
            | head -n1 || true
          )"
          echo "Raw APP_VERSION tag: '${APP_VERSION}'"

          CHART_VERSION="$(
            git tag -l '${{ env.MODULE }}-chart/*' --sort=-version:refname \
            | head -n1 || true
          )"
          echo "Raw CHART_VERSION tag: '${CHART_VERSION}'"

          echo
          echo "=== Applying fallbacks if empty ==="
          APP_VERSION="${APP_VERSION:-${{ env.MODULE }}/0.0.1}"
          CHART_VERSION="${CHART_VERSION:-${{ env.MODULE }}-chart/0.0.1}"
          echo "After fallback → APP_VERSION='${APP_VERSION}'"
          echo "After fallback → CHART_VERSION='${CHART_VERSION}'"

          echo
          echo "=== Stripping prefix (keep only part after last '/') ==="
          APP_VERSION="${APP_VERSION##*/}"
          CHART_VERSION="${CHART_VERSION##*/}"
          echo "After strip → APP_VERSION='${APP_VERSION}'"
          echo "After strip → CHART_VERSION='${CHART_VERSION}'"

          {
            echo "APP_VERSION=$APP_VERSION"
            echo "CHART_VERSION=$CHART_VERSION"
          } >> "$GITHUB_ENV"

      - name: Echo
        run: |
          echo "APP_VERSION=${{ env.APP_VERSION }}"
          echo "CHART_VERSION=${{ env.CHART_VERSION }}"

      - name: Replace CHART_VERSION in ./${{ env.MODULE }}-chart/Chart.yaml
        run: sed -i 's/CHART_VERSION/${{ env.CHART_VERSION }}/g' ./${{ env.MODULE }}-chart/Chart.yaml

      - name: Replace APP_VERSION in ./${{ env.MODULE }}-chart/Chart.yaml
        run: sed -i 's/APP_VERSION/${{ env.APP_VERSION }}/g' ./${{ env.MODULE }}-chart/Chart.yaml

      - name: Set up Helm
        uses: azure/setup-helm@v4.1.0

      - name: Helm lint chart
        run: helm lint ./${{ env.MODULE }}-chart

      - name: Create k8s Kind Cluster
        uses: helm/kind-action@v1

      # Create the aso-credential secret to be used by Azure Service Operator.
      - name: Create ASO Credential Secret
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: aso-credential
            namespace: default
          stringData:
            AZURE_SUBSCRIPTION_ID: "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            AZURE_TENANT_ID: "${{ secrets.AZURE_TENANT_ID }}"
            AZURE_CLIENT_ID: "${{ secrets.AZURE_CLIENT_ID }}"
            AZURE_CLIENT_SECRET: "${{ secrets.AZURE_CLIENT_SECRET }}"
          EOF

      - name: Install cert-manager via Helm
        run: |
          helm install \
            cert-manager oci://quay.io/jetstack/charts/cert-manager \
            --version v1.19.1 \
            --namespace cert-manager \
            --create-namespace \
            --set crds.enabled=true \
            --wait

      - name: Install Azure Service Operator on Kind using Helm
        run: |
          helm repo add aso2 https://raw.githubusercontent.com/Azure/azure-service-operator/main/v2/charts
          helm repo update
          helm install aso2 aso2/azure-service-operator --create-namespace --wait --version=2.16.0 --namespace=azureserviceoperator-system --set crdPattern='resources.azure.com/*;network.azure.com/*;redhatopenshift.azure.com/*;authorization.azure.com/*' --set replicaCount=1

      # Prepare a sanitized version string (replace '.' with '-') and store it in K8S_VERSION_NODOT
      - name: Prepare version variable
        run: echo "K8S_VERSION_NODOT=$(echo '${{ matrix.k8s_version }}' | tr '.' '-')" >> $GITHUB_ENV

      # Prepare a sanitized version string (remove '.' entirely) and store it in K8S_VERSION_NODOT2
      - name: Prepare version variable
        run: echo "K8S_VERSION_NODOT2=$(echo '${{ matrix.k8s_version }}' | tr -d '.')" >> $GITHUB_ENV


      # Create a ResourceGroup CR that will serve as the owner for the OpenShiftCluster.
      - name: Deploy ResourceGroup CR via ASO
        run: |
          echo "Deploying ResourceGroup openshiftcluster-$K8S_VERSION_NODOT for Kubernetes version ${{ matrix.k8s_version }}..."
          cat <<EOF | kubectl apply -f -
          apiVersion: resources.azure.com/v1api20200601
          kind: ResourceGroup
          metadata:
            name: openshiftcluster-$K8S_VERSION_NODOT
            namespace: default
          spec:
            location: northeurope
          EOF

      - name: Wait for ResourceGroup Provisioning
        run: |
          echo "Waiting for ResourceGroup openshiftcluster-$K8S_VERSION_NODOT to become Ready..."
          kubectl wait --for=condition=Ready --timeout=600s resourcegroup/openshiftcluster-$K8S_VERSION_NODOT

      - name: Deploy VirtualNetwork CR via ASO
        run: |
          echo "Deploying VirtualNetwork openshiftcluster-$K8S_VERSION_NODOT for Kubernetes version ${{ matrix.k8s_version }}..."
          cat <<EOF | kubectl apply -f -
          apiVersion: network.azure.com/v1api20240301
          kind: VirtualNetwork
          metadata:
            name: openshiftcluster-$K8S_VERSION_NODOT
            namespace: default
          spec:
            location: northeurope
            owner:
              name: openshiftcluster-$K8S_VERSION_NODOT
            addressSpace:
              addressPrefixes:
                - 10.0.0.0/22
          EOF

      - name: Wait for VirtualNetwork Provisioning
        run: |
          echo "Waiting for VirtualNetwork openshiftcluster-$K8S_VERSION_NODOT to become Ready..."
          kubectl wait --for=condition=Ready --timeout=600s virtualnetwork/openshiftcluster-$K8S_VERSION_NODOT

      - name: Deploy VirtualNetworksSubnet CR via ASO
        run: |
          echo "Deploying VirtualNetworksSubnet openshiftcluster-$K8S_VERSION_NODOT-master for Kubernetes version ${{ matrix.k8s_version }}..."
          cat <<EOF | kubectl apply -f -
          apiVersion: network.azure.com/v1api20240301
          kind: VirtualNetworksSubnet
          metadata:
            name: openshiftcluster-$K8S_VERSION_NODOT-master
            namespace: default
          spec:
            owner:
              name: openshiftcluster-$K8S_VERSION_NODOT
            addressPrefix: 10.0.0.0/23
          EOF

      - name: Wait for VirtualNetworksSubnet Provisioning
        run: |
          echo "Waiting for VirtualNetworksSubnet openshiftcluster-$K8S_VERSION_NODOT-master to become Ready..."
          kubectl wait --for=condition=Ready --timeout=600s virtualnetworkssubnet/openshiftcluster-$K8S_VERSION_NODOT-master

      - name: Deploy VirtualNetworksSubnet CR via ASO
        run: |
          echo "Deploying VirtualNetworksSubnet openshiftcluster-$K8S_VERSION_NODOT-worker for Kubernetes version ${{ matrix.k8s_version }}..."
          cat <<EOF | kubectl apply -f -
          apiVersion: network.azure.com/v1api20240301
          kind: VirtualNetworksSubnet
          metadata:
            name: openshiftcluster-$K8S_VERSION_NODOT-worker
            namespace: default
          spec:
            owner:
              name: openshiftcluster-$K8S_VERSION_NODOT
            addressPrefix: 10.0.2.0/23
          EOF

      - name: Wait for VirtualNetworksSubnet Provisioning
        run: |
          echo "Waiting for VirtualNetworksSubnet openshiftcluster-$K8S_VERSION_NODOT-worker to become Ready..."
          kubectl wait --for=condition=Ready --timeout=600s virtualnetworkssubnet/openshiftcluster-$K8S_VERSION_NODOT-worker

      - name: Deploy RoleAssignment CR via ASO
        run: |
          echo "Deploying RoleAssignment openshiftcluster-$K8S_VERSION_NODOT for Kubernetes version ${{ matrix.k8s_version }}..."
          cat <<EOF | kubectl apply -f -
          apiVersion: authorization.azure.com/v1api20220401
          kind: RoleAssignment
          metadata:
            name: openshiftcluster-$K8S_VERSION_NODOT
            namespace: default
          spec:
            # This resource can be owner by any resource. In this example we've chosen a resource group for simplicity
            owner:
              name: openshiftcluster-$K8S_VERSION_NODOT
              group: network.azure.com
              kind: VirtualNetwork
            # This is the Principal ID of the AAD identity to which the role will be assigned
            principalId: ${{ secrets.AZURE_PRINCIPAL_ID }}
            principalType: ServicePrincipal
            roleDefinitionReference:
              # This ARM ID represents "Contributor" - you can read about other built in roles here: https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles
              armId: /subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/providers/Microsoft.Authorization/roleDefinitions/4d97b98b-1d4f-4787-a291-c67834d212e7
          EOF

      - name: Wait for RoleAssignment Provisioning
        run: |
          echo "Waiting for RoleAssignment openshiftcluster-$K8S_VERSION_NODOT to become Ready..."
          kubectl wait --for=condition=Ready --timeout=600s roleassignment/openshiftcluster-$K8S_VERSION_NODOT

      - name: Deploy OpenShiftCluster CR via ASO
        run: |
          echo "Deploying OpenShiftCluster openshiftcluster-$K8S_VERSION_NODOT with Kubernetes version ${{ matrix.k8s_version }}..."
          cat <<EOF | kubectl apply -f -
          apiVersion: redhatopenshift.azure.com/v1api20231122
          kind: OpenShiftCluster
          metadata:
            name: openshiftcluster-$K8S_VERSION_NODOT
          spec:
            owner:
              name: openshiftcluster-$K8S_VERSION_NODOT
            location: "northeurope"
            clusterProfile:
              domain: openshiftcluster$K8S_VERSION_NODOT2
              version: "${{ matrix.k8s_version }}"
              resourceGroupId: /subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/openshiftcluster-$K8S_VERSION_NODOT-cluster
              fipsValidatedModules: Disabled
            ingressProfiles:
              - name: default
                visibility: Public
            masterProfile:
              vmSize: Standard_D8s_v3
              encryptionAtHost: Disabled
              subnetReference:
                group: network.azure.com
                kind: VirtualNetworksSubnet
                name: openshiftcluster-$K8S_VERSION_NODOT-master
            workerProfiles:
            - count: 3
              diskSizeGB: 128
              name: worker
              vmSize: Standard_D4s_v3
              encryptionAtHost: Disabled
              subnetReference:
                group: network.azure.com
                kind: VirtualNetworksSubnet
                name: openshiftcluster-$K8S_VERSION_NODOT-worker
            servicePrincipalProfile:
              clientId: ${{ secrets.AZURE_CLIENT_ID }}
              clientSecret:
                key: AZURE_CLIENT_SECRET
                name: aso-credential
            networkProfile:
              podCidr: 10.128.0.0/14
              serviceCidr: 172.30.0.0/16
            apiserverProfile:
              visibility: Public
            operatorSpec:
              secrets:
                adminCredentials:
                  name: admincredentials
                  key: admincredentials
                username:
                  name: credentials
                  key: username
                password:
                  name: credentials
                  key: password
          EOF

      - name: Wait for OpenShiftCluster Provisioning
        run: |
          kubectl get openshiftcluster/openshiftcluster-$K8S_VERSION_NODOT -o yaml

      - name: Wait for OpenShiftCluster Provisioning
        run: |
          echo "Waiting for OpenShiftCluster openshiftcluster-$K8S_VERSION_NODOT to become Ready..."
          kubectl wait --for=condition=Ready --timeout=3600s openshiftcluster/openshiftcluster-$K8S_VERSION_NODOT

      # TO DELETE 
      - name: Get OpenShiftCluster YAML
        if: always()
        run: |
          kubectl get openshiftcluster/openshiftcluster-$K8S_VERSION_NODOT -o yaml

      # TO DELETE 
      - name: Get secrets
        if: always()
        run: |
          kubectl get secrets -A
          kubectl get secret admincredentials -o yaml
          kubectl get secret credentials -o yaml

      - name: Retrieve OpenShiftCluster Kubeconfig
        run: |
          echo "Extracting kubeconfig from secret..."
          kubectl get secret admincredentials -o jsonpath='{.data.admincredentials}' | base64 -d | base64 -d > openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml
          echo "cat openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml..."
          cat openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml

      - name: Install ${{ env.MODULE }}-crd chart
        if: env.INSTALL_CRDS == 'true'
        run: |
          helm repo add krateo https://charts.krateo.io
          helm repo update krateo
          helm install ${{ env.MODULE }}-crd krateo/${{ env.MODULE }}-crd \
            --create-namespace -n krateo-system --wait \
            --kubeconfig=openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml --kube-insecure-skip-tls-verify

      - name: Get ${{ env.MODULE }}-crd
        if: env.INSTALL_CRDS == 'true'
        run: |
          kubectl get crd \
            --kubeconfig=openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml --insecure-skip-tls-verify=true

      - name: Install ${{ env.MODULE }} chart
        run: |
          helm install ${{ env.MODULE }} ./${{ env.MODULE }}-chart \
            --create-namespace -n krateo-system --wait \
            --kubeconfig=openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml \
            --set krateoplatformops.service.type=LoadBalancer \
            --set krateoplatformops.service.externalIpAvailable=true \
            --set krateoplatformops.finopscratedb.openshift.enabled=true --kube-insecure-skip-tls-verify

      - name: Wait for ${{ env.MODULE }} deployment to become Available
        if: env.HAS_DEPLOYMENT == 'true'
        run: |
          kubectl wait deployment ${{ env.MODULE }} --for condition=Available=True \
            --timeout=120s --namespace krateo-system \
            --kubeconfig=openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml --insecure-skip-tls-verify=true

      - name: Wait for krateoplatformops krateo to become ready
        run: |
          kubectl get krateoplatformops -A
          kubectl wait krateoplatformops krateo --for condition=Ready=True --timeout=600s --namespace krateo-system--kubeconfig=openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml --insecure-skip-tls-verify=true

      - name: Get Krateo PlatformOps CR status on OpenShiftCluster
        if: always()
        run: kubectl get krateoplatformops krateo --namespace krateo-system--kubeconfig=openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml -o yaml --insecure-skip-tls-verify=true

      - name: Get events on OpenShiftCluster
        if: always()
        run: kubectl get events -A --sort-by='.lastTimestamp' --kubeconfig=openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml --kube-insecure-skip-tls-verify

      - name: Clean Up Krateo PlatformOps CR on OpenShiftCluster
        if: always()
        run: kubectl delete krateoplatformops krateo --namespace krateo-system--kubeconfig=openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml --kube-insecure-skip-tls-verify

      - name: Clean Up Installer Helm Chart on OpenShiftCluster
        if: always()
        run: helm uninstall installer-$K8S_VERSION_NODOT --namespace krateo-system--kubeconfig=openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml --kube-insecure-skip-tls-verify

      - name: Clean Up krateo-system namespace on OpenShiftCluster
        if: always()
        run: kubectl delete namespace krateo-system--kubeconfig=openshiftcluster-$K8S_VERSION_NODOT-kubeconfig.yaml --kube-insecure-skip-tls-verify

      - name: Clean Up OpenShiftCluster Resource
        if: always()
        run: kubectl delete openshiftcluster/openshiftcluster-$K8S_VERSION_NODOT

      - name: Clean Up RoleAssignment Resource
        if: always()
        run: kubectl delete roleassignment/openshiftcluster-$K8S_VERSION_NODOT

      - name: Clean Up VirtualNetworksSubnet Resource
        if: always()
        run: kubectl delete virtualnetworkssubnet/openshiftcluster-$K8S_VERSION_NODOT-worker

      - name: Clean Up VirtualNetworksSubnet Resource
        if: always()
        run: kubectl delete virtualnetworkssubnet/openshiftcluster-$K8S_VERSION_NODOT-master

      - name: Clean Up VirtualNetwork Resource
        if: always()
        run: kubectl delete virtualnetwork/openshiftcluster-$K8S_VERSION_NODOT

      - name: Clean Up ResourceGroup CR
        if: always()
        run: kubectl delete resourcegroups/openshiftcluster-$K8S_VERSION_NODOT

      - name: Get events
        if: always()
        run: |
          kubectl get events -A --sort-by='.lastTimestamp'